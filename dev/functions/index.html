<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods · Alpine</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Alpine</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../installation/">How to Use</a></li><li><a class="tocitem" href="../choosingsolver/">Choosing Sub-Solvers</a></li><li><a class="tocitem" href="../algorithm/">Algorithm</a></li><li><a class="tocitem" href="../expression/">Expression Guideline</a></li><li><a class="tocitem" href="../parameters/">Parameters</a></li><li class="is-active"><a class="tocitem" href>Methods</a><ul class="internal"><li><a class="tocitem" href="#High-level-Algorithmic-Operations-1"><span>High-level Algorithmic Operations</span></a></li><li><a class="tocitem" href="#Adapative-Partitioning-Methods-1"><span>Adapative Partitioning Methods</span></a></li><li><a class="tocitem" href="#Presolve-Methods-1"><span>Presolve Methods</span></a></li><li><a class="tocitem" href="#Utility-Methods-1"><span>Utility Methods</span></a></li></ul></li><li><a class="tocitem" href="../hacking/">Hacking Alpine</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Methods</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lanl-ansi/Alpine.jl/blob/master/docs/src/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions-1"><a class="docs-heading-anchor" href="#Functions-1">Functions</a><a class="docs-heading-anchor-permalink" href="#Functions-1" title="Permalink"></a></h1><h2 id="High-level-Algorithmic-Operations-1"><a class="docs-heading-anchor" href="#High-level-Algorithmic-Operations-1">High-level Algorithmic Operations</a><a class="docs-heading-anchor-permalink" href="#High-level-Algorithmic-Operations-1" title="Permalink"></a></h2><p>These are the high-level algorithmic methods:</p><article class="docstring"><header><a class="docstring-binding" id="Alpine.presolve" href="#Alpine.presolve"><code>Alpine.presolve</code></a> — <span class="docstring-category">Function</span></header><section><div><p>presolve(m::AlpineNonlinearModel)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/95c102ceadb9eb4f60a25d205594cff3a585e748/src/algorithm.jl#L68-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alpine.global_solve" href="#Alpine.global_solve"><code>Alpine.global_solve</code></a> — <span class="docstring-category">Function</span></header><section><div><p>global_solve(m::AlpineNonlinearModel)</p><p>Perform global optimization algorithm that is based on the adaptive piecewise convexification. This iterative algorithm loops over <a href="#Alpine.bounding_solve"><code>bounding_solve</code></a> and <a href="#Alpine.local_solve"><code>local_solve</code></a> until the optimality gap between the lower bound (relaxed problem with min. objective) and the upper bound (feasible problem) is within the user prescribed limits. Each <a href="#Alpine.bounding_solve"><code>bounding_solve</code></a> provides a lower bound that serves as the partitioning point for the next iteration (this feature can be modified given a different <code>add_adaptive_partition</code>). Each <a href="#Alpine.local_solve"><code>local_solve</code></a> provides an incumbent feasible solution. The algorithm terminates when atleast one of these conditions are satisfied: time limit, optimality condition, or iteration limit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/95c102ceadb9eb4f60a25d205594cff3a585e748/src/algorithm.jl#L17-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alpine.local_solve" href="#Alpine.local_solve"><code>Alpine.local_solve</code></a> — <span class="docstring-category">Function</span></header><section><div><p>local_solve(m::AlpineNonlinearModel, presolve::Bool=false)</p><p>Perform a local NLP or MINLP solve to obtain a feasible solution. The <code>presolve</code> option is set to <code>true</code> when the function is invoked in <a href="#Alpine.presolve"><code>presolve</code></a>. Otherwise, the function is invoked from <a href="#Alpine.bounding_solve"><code>bounding_solve</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/95c102ceadb9eb4f60a25d205594cff3a585e748/src/algorithm.jl#L158-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alpine.bounding_solve" href="#Alpine.bounding_solve"><code>Alpine.bounding_solve</code></a> — <span class="docstring-category">Function</span></header><section><div><p>bounding_solve(m::AlpineNonlinearModel; kwargs...)</p><p>This process usually deals with a MILP or a MIQCP/MIQCQP problem for lower bounding the given problem. It solves the problem built upon a convexification base on a discretization Dictionary of some variables. The convexification utilized is Tighten McCormick scheme. See <code>create_bounding_mip</code> for more details of the problem solved here.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/95c102ceadb9eb4f60a25d205594cff3a585e748/src/algorithm.jl#L267-L276">source</a></section></article><h2 id="Adapative-Partitioning-Methods-1"><a class="docs-heading-anchor" href="#Adapative-Partitioning-Methods-1">Adapative Partitioning Methods</a><a class="docs-heading-anchor-permalink" href="#Adapative-Partitioning-Methods-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Alpine.create_bounding_mip" href="#Alpine.create_bounding_mip"><code>Alpine.create_bounding_mip</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">create_bounding_mip(m::AlpineNonlinearModel; use_disc::Dict)</code></pre><p>Set up a JuMP MILP bounding model base on variable domain partitioning information stored in <code>use_disc</code>. By default, if <code>use_disc is</code> not provided, it will use <code>m.discretizations</code> store in the Alpine model. The basic idea of this MILP bounding model is to use Tighten McCormick to convexify the original Non-convex region. Among all presented partitions, the bounding model will choose one specific partition as the lower bound solution. The more partitions there are, the better or finer bounding model relax the original MINLP while the more efforts required to solve this MILP is required.</p><p>This function is implemented in the following manner:</p><pre><code class="language-none">* [`amp_post_vars`](@ref): post original and lifted variables
* [`amp_post_lifted_constraints`](@ref): post original and lifted constraints
* [`amp_post_lifted_obj`](@ref): post original or lifted objective function
* [`amp_post_tmc_mccormick`](@ref): post Tighten McCormick variables and constraints base on `discretization` information</code></pre><p>More specifically, the Tightening McCormick used here can be generalized in the following mathematical formulation. Consider a nonlinear term</p><div>\[\begin{subequations}
\begin{align}
   &amp;\widehat{x_{ij}} \geq (\mathbf{x}_i^l\cdot\hat{\mathbf{y}}_i) x_j + (\mathbf{x}_j^l\cdot\hat{\mathbf{y}}_j) x_i - (\mathbf{x}_i^l\cdot\hat{\mathbf{y}}_i)(\mathbf{x}_j^l\cdot\hat{\mathbf{y}}_j) \\
   &amp;\widehat{x_{ij}} \geq (\mathbf{x}_i^u\cdot\hat{\mathbf{y}}_i) x_j + (\mathbf{x}_j^u\cdot\hat{\mathbf{y}}_j) x_i - (\mathbf{x}_i^u\cdot\hat{\mathbf{y}}_i)(\mathbf{x}_j^u\cdot\hat{\mathbf{y}}_j) \\
   &amp;\widehat{x_{ij}} \leq (\mathbf{x}_i^l\cdot\hat{\mathbf{y}}_i) x_j + (\mathbf{x}_j^u\cdot\hat{\mathbf{y}}_j) x_i - (\mathbf{x}_i^l\cdot\hat{\mathbf{y}}_i)(\mathbf{x}_j^u\cdot\hat{\mathbf{y}}_j) \\
   &amp;\widehat{x_{ij}} \leq (\mathbf{x}_i^u\cdot\hat{\mathbf{y}}_i) x_j + (\mathbf{x}_j^l\cdot\hat{\mathbf{y}}_j) x_i - (\mathbf{x}_i^u\cdot\hat{\mathbf{y}}_i)(\mathbf{x}_j^l\cdot\hat{\mathbf{y}}_j) \\
   &amp; \mathbf{x}_i^u\cdot\hat{\mathbf{y}}_i) \geq x_{i} \geq \mathbf{x}_i^l\cdot\hat{\mathbf{y}}_i) \\
   &amp; \mathbf{x}_j^u\cdot\hat{\mathbf{y}}_j) \geq x_{j} \geq \mathbf{x}_j^l\cdot\hat{\mathbf{y}}_j) \\
   &amp;\sum \hat{\mathbf{y}_i} = 1, \ \ \sum \hat{\mathbf{y}_j}_k = 1 \\
   &amp;\hat{\mathbf{y}}_i \in \{0,1\}, \hat{\mathbf{y}}_j \in \{0,1\}
\end{align}
\end{subequations}\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/95c102ceadb9eb4f60a25d205594cff3a585e748/src/amp.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alpine.pick_disc_vars" href="#Alpine.pick_disc_vars"><code>Alpine.pick_disc_vars</code></a> — <span class="docstring-category">Function</span></header><section><div><p>pick<em>disc</em>vars(m::AlpineNonlinearModel)</p><p>This function helps pick the variables for discretization. The method chosen depends on user-inputs. In case when <code>indices::Int</code> is provided, the method is chosen as built-in method. Currently, there are two built-in options for users as follows:</p><ul><li><code>max-cover (m.disc_var_pick=0, default)</code>: pick all variables involved in the non-linear term for discretization</li><li><code>min-vertex-cover (m.disc_var_pick=1)</code>: pick a minimum vertex cover for variables involved in non-linear terms so that each non-linear term is at least convexified</li></ul><p>For advanced usage, <code>m.disc_var_pick</code> allows <code>::Function</code> inputs. User can provide his/her own function to choose the variables for discretization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/95c102ceadb9eb4f60a25d205594cff3a585e748/src/algorithm.jl#L328-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alpine.fix_domains" href="#Alpine.fix_domains"><code>Alpine.fix_domains</code></a> — <span class="docstring-category">Function</span></header><section><div><p>fix_domains(m::AlpineNonlinearModel)</p><p>This function is used to fix variables to certain domains during the local solve process in the <a href="#Alpine.global_solve"><code>global_solve</code></a>. More specifically, it is used in <a href="#Alpine.local_solve"><code>local_solve</code></a> to fix binary and integer variables to lower bound solutions and discretizing variables to the active domain according to lower bound solution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/95c102ceadb9eb4f60a25d205594cff3a585e748/src/utility.jl#L211-L218">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>min_vertex_cover</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>max_cover</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Presolve-Methods-1"><a class="docs-heading-anchor" href="#Presolve-Methods-1">Presolve Methods</a><a class="docs-heading-anchor-permalink" href="#Presolve-Methods-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Alpine.bound_tightening" href="#Alpine.bound_tightening"><code>Alpine.bound_tightening</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bound_tightening(m::AlpineNonlinearModel)

Entry point for the optimization-based bound-tightening (OBBT) algorithm. The aim of the OBBT algorithm</code></pre><p>is to sequentially tighten the variable bounds until a fixed point is reached.</p><p>Currently, two OBBT methods are implemented <a href="#Alpine.minmax_bound_tightening"><code>minmax_bound_tightening</code></a>.</p><pre><code class="language-none">* Bound-tightening with polyhedral relaxations (McCormick, Lambda for convex-hull) 
* Bound-tightening with piecewise polyhedral relaxations: (with three partitions around the local feasible solution)
If no local feasible solution is obtained, the algorithm defaults to OBBT without partitions</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/95c102ceadb9eb4f60a25d205594cff3a585e748/src/presolve.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alpine.minmax_bound_tightening" href="#Alpine.minmax_bound_tightening"><code>Alpine.minmax_bound_tightening</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">minmax_bound_tightening(m:AlpineNonlinearModel; use_bound::Bool=true, use_tmc::Bool)</code></pre><p>This function implements the OBBT algorithm to tighten the variable bounds. It utilizes either the basic polyhedral relaxations or the piecewise polyhedral relaxations (TMC) to tighten the bounds. The TMC has additional binary variables while performing OBBT.</p><p>The algorithm as two main parameters. The first is the <code>use_tmc</code>, which when set to <code>true</code> invokes the algorithm on the TMC relaxation. The second parameter <code>use_bound</code> takes in the objective value of the local solve solution stored in <code>best_sol</code> for performing OBBT. The <code>use_bound</code> option is set to <code>true</code> when the local solve is successful in obtaining a feasible solution, else this parameter is set to <code>false</code></p><p>For details, refer to section 3.1.1 of  Nagarjan, Lu, Wang, Bent, Sundar, &quot;An adaptive, multivariate partitioning algorithm for global optimization of nonconvex programs&quot;  URL: https://goo.gl/89zrDf</p><p>Several other parameters are available for the OBBT algorithm tuning. For more details, see <a href="../parameters/#Parameters-1">Parameters</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/95c102ceadb9eb4f60a25d205594cff3a585e748/src/presolve.jl#L30-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alpine.create_bound_tightening_model" href="#Alpine.create_bound_tightening_model"><code>Alpine.create_bound_tightening_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">create_bound_tightening_model(m::AlpineNonlinearModel, discretization::Dict, bound::Float64)</code></pre><p>This function takes in the initial discretization information and builds the OBBT model. It is an algorithm specific function called by <a href="#Alpine.minmax_bound_tightening"><code>minmax_bound_tightening</code></a></p><pre><code class="language-none"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/95c102ceadb9eb4f60a25d205594cff3a585e748/src/presolve.jl#L181-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alpine.solve_bound_tightening_model" href="#Alpine.solve_bound_tightening_model"><code>Alpine.solve_bound_tightening_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">solve_bound_tightening_model(m::AlpineNonlinearModel)</code></pre><p>A function that solves the min and max OBBT model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/95c102ceadb9eb4f60a25d205594cff3a585e748/src/presolve.jl#L209-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alpine.resolve_var_bounds" href="#Alpine.resolve_var_bounds"><code>Alpine.resolve_var_bounds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">resolve_var_bounds(m::AlpineNonlinearModel)</code></pre><p>Resolve the bounds of the lifted variable using the information in l<em>var</em>tight and u<em>var</em>tight. This method only takes in known or trivial bounds information to reason lifted variable bound to avoid the cases of infinity bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/95c102ceadb9eb4f60a25d205594cff3a585e748/src/bounds.jl#L257-L262">source</a></section><section><div><pre><code class="language-none">resolve_var_bounds(nonconvex_terms::Dict, discretization::Dict)

For discretization to be performed, we do not allow for a variable being discretized to have infinite bounds.
The lifted variables will have infinite bounds and the function infers bounds on these variables. This process
can help speed up the subsequent solve in subsequent iterations.

Only used in presolve bound tightening</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/95c102ceadb9eb4f60a25d205594cff3a585e748/src/bounds.jl#L320-L328">source</a></section></article><h2 id="Utility-Methods-1"><a class="docs-heading-anchor" href="#Utility-Methods-1">Utility Methods</a><a class="docs-heading-anchor-permalink" href="#Utility-Methods-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Alpine.update_var_bounds" href="#Alpine.update_var_bounds"><code>Alpine.update_var_bounds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">update_var_bounds(m::AlpineNonlinearModel, discretization::Dict; len::Float64=length(keys(discretization)))</code></pre><p>This function take in a dictionary-based discretization information and convert them into two bounds vectors (l<em>var, u</em>var) by picking the smallest and largest numbers. User can specify a certain length that may contains variables that is out of the scope of discretization.</p><p>Output::</p><pre><code class="language-none">l_var::Vector{Float64}, u_var::Vector{Float64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/95c102ceadb9eb4f60a25d205594cff3a585e748/src/bounds.jl#L384-L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alpine.discretization_to_bounds" href="#Alpine.discretization_to_bounds"><code>Alpine.discretization_to_bounds</code></a> — <span class="docstring-category">Function</span></header><section><div><p>discretization<em>to</em>bounds(d::Dict, l::Int)</p><p>Same as <a href="#Alpine.update_var_bounds"><code>update_var_bounds</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/95c102ceadb9eb4f60a25d205594cff3a585e748/src/utility.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alpine.init_disc" href="#Alpine.init_disc"><code>Alpine.init_disc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">init_disc(m::AlpineNonlinearModel)</code></pre><p>This function initialize the dynamic discretization used for any bounding models. By default, it takes (.l<em>var</em>orig, .u<em>var</em>orig) as the base information. User is allowed to use alternative bounds for initializing the discretization dictionary. The output is a dictionary with MathProgBase variable indices keys attached to the :AlpineNonlinearModel.discretization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/95c102ceadb9eb4f60a25d205594cff3a585e748/src/bounds.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alpine.to_discretization" href="#Alpine.to_discretization"><code>Alpine.to_discretization</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">to_discretization(m::AlpineNonlinearModel, lbs::Vector{Float64}, ubs::Vector{Float64})</code></pre><p>Utility functions to convert bounds vectors to Dictionary based structures that is more suitable for partition operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/95c102ceadb9eb4f60a25d205594cff3a585e748/src/bounds.jl#L49-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alpine.flatten_discretization" href="#Alpine.flatten_discretization"><code>Alpine.flatten_discretization</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">flatten_discretization(discretization::Dict)</code></pre><p>Utility functions to eliminate all partition on discretizing variable and keep the loose bounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/95c102ceadb9eb4f60a25d205594cff3a585e748/src/bounds.jl#L87-L92">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>add_adpative_partition</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Alpine.update_mip_time_limit" href="#Alpine.update_mip_time_limit"><code>Alpine.update_mip_time_limit</code></a> — <span class="docstring-category">Function</span></header><section><div><p>update<em>mip</em>time_limit(m::AlpineNonlinearModel) An utility function used to dynamically regulate MILP solver time limits to fit Alpine solver time limits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/Alpine.jl/blob/95c102ceadb9eb4f60a25d205594cff3a585e748/src/utility.jl#L809-L812">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>fetch_timeleft_symbol</code>. Check Documenter&#39;s build log for details.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../parameters/">« Parameters</a><a class="docs-footer-nextpage" href="../hacking/">Hacking Alpine »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 6 December 2019 22:26">Friday 6 December 2019</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
